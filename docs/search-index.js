var searchIndex = {};
searchIndex["glitter"] = {"doc":"A type-safe, zero-cost OpenGL abstraction.","items":[[0,"context","glitter","Home of `ContextOf`, which is the type that represents \"the OpenGL state machine\", and the type you use to make OpenGL calls.",null,null],[3,"ContextOf","glitter::context","The type that represents the whole \"OpenGL state machine\". This is the core of glitter's design, and what enables the notion of safety.",null,null],[0,"buffer_context","","Contains all of the OpenGL state types related to buffer objects.",null,null],[3,"ArrayBufferBinding","glitter::context::buffer_context","Represents a buffer that has been bound to the `GL_ARRAY_BUFFER` binding target.",null,null],[3,"ElementArrayBufferBinding","","Represents a buffer that has been bound to the `GL_ELEMENT_ARRAY_BUFFER` binding target.",null,null],[3,"BufferBinderOf","","This type holds all of the OpenGL-state-related buffer objects. See the `ContextOf` docs for more details.",null,null],[3,"ArrayBufferBinder","","The OpenGL state representing the `GL_ARRAY_BUFFER` target.",null,null],[3,"ElementArrayBufferBinder","","The OpenGL state representing the `GL_ELEMENT_ARRAY_BUFFER` target.",null,null],[6,"BufferBinder","","A part of the OpenGL context that has all free buffer bindings.",null,null],[8,"ContextBufferExt","","An extension trait that includes buffer-object-related OpenGL methods.",null,null],[11,"gen_buffer","","Create a new, empty OpenGL buffer object.",0,{"inputs":[{"name":"self"}],"output":{"name":"buffer"}}],[11,"buffer_bytes","","Send data to a buffer object. Note that this will replace the buffer's current contents, if any.",0,null],[11,"vertex_attrib_pointer","","Specify how an array of vertex data will be treated while rendering. Most uses of this function can be replaced by using a [`VertexBuffer`] (../../vertex_buffer/struct.VertexBuffer.html), which provides a nicer interface for setting up vertex attributes.",0,{"inputs":[{"name":"self"},{"name":"programattrib"},{"name":"i8"},{"name":"datatype"},{"name":"bool"},{"name":"usize"},{"name":"usize"}],"output":null}],[11,"draw_arrays_range","","Use the vertex data from the provided array buffer binding to render primitives.",0,{"inputs":[{"name":"self"},{"name":"arraybufferbinding"},{"name":"drawingmode"},{"name":"u32"},{"name":"usize"}],"output":null}],[11,"draw_n_elements_buffered","","Draw primitives specified by the provided element array buffer, treated as indices of the vertices from the provided array buffer.",0,{"inputs":[{"name":"self"},{"name":"arraybufferbinding"},{"name":"elementarraybufferbinding"},{"name":"drawingmode"},{"name":"usize"},{"name":"indexdatumtype"}],"output":null}],[11,"draw_n_elements","","Draw primitives specified by the provided index array, treated as indices of the vertices from the provided array buffer.",0,null],[11,"draw_elements","","Draw primitives specified by the provided index array, treated as indices of the vertices from the provided array buffer.",0,null],[8,"ArrayBufferContext","","An OpenGL context that has a free `GL_ARRAY_BUFFER` binding.",null,null],[16,"Binder","","The type of binder this context contains.",1,null],[16,"Rest","","The OpenGL context that will be returned after binding the array buffer.",1,null],[10,"split_array_buffer","","Split this context into a binder and the remaining context.",1,null],[11,"bind_array_buffer","","Bind a buffer to this context's array buffer, returning a new context and a binding.",1,null],[8,"ElementArrayBufferContext","","An OpenGL context that has a free `GL_ELEMENT_ARRAY_BUFFER` binding.",null,null],[16,"Binder","","The type of binder this context contains.",2,null],[16,"Rest","","The OpenGL context that will be returned after binding the element array buffer.",2,null],[10,"split_element_array_buffer","","Split this context into a binder and the remaining context.",2,null],[11,"bind_element_array_buffer","","Bind a buffer to this context's element array buffer, returning a new context and a binding.",2,null],[8,"BufferContext","","An OpenGL context that has all free buffer bindings. This trait implies both `ArrayBufferContext` and `ElementArrayBufferContext`.",null,null],[8,"BufferBinding","","A buffer that has been bound to an OpenGL buffer binding point.",null,null],[10,"target","","Returns the OpenGL binding target that this buffer binding references.",3,{"inputs":[{"name":"self"}],"output":{"name":"bufferbindingtarget"}}],[11,"split_array_buffer","glitter::context","",4,null],[11,"split_element_array_buffer","","",4,null],[11,"target","glitter::context::buffer_context","",5,{"inputs":[{"name":"self"}],"output":{"name":"bufferbindingtarget"}}],[11,"target","","",6,{"inputs":[{"name":"self"}],"output":{"name":"bufferbindingtarget"}}],[11,"current","","Get the current buffer-object binders.",7,{"inputs":[],"output":{"name":"bufferbinder"}}],[11,"swap_array","","Replace the array-buffer-related context with a new value, returning the old value and a new buffer context.",7,null],[11,"swap_element_array","","Replace the element-array-buffer-related context with a new value, returning the old value and a new buffer context.",7,null],[11,"current","","Get the current `GL_ARRAY_BUFFER` binder.",8,{"inputs":[],"output":{"name":"self"}}],[11,"bind","","Bind a buffer to the `GL_ARRAY_BUFFER` target, returning a binding.",8,{"inputs":[{"name":"self"},{"name":"buffer"}],"output":{"name":"arraybufferbinding"}}],[11,"current","","Get the current `GL_ELEMENT_ARRAY_BUFFER` binder.",9,{"inputs":[],"output":{"name":"self"}}],[11,"bind","","Bind a buffer to the `GL_ELEMENT_ARRAY_BUFFER` target, returning a binding.",9,{"inputs":[{"name":"self"},{"name":"buffer"}],"output":{"name":"elementarraybufferbinding"}}],[0,"framebuffer_context","glitter::context","Contains all of the OpenGL state types related to framebuffer objects.",null,null],[3,"FramebufferBuilder","glitter::context::framebuffer_context","Provides a safe interface for building a framebuffer object that is checked to be framebuffer-complete. A `FramebufferBuilder` can be created using the [`gl.build_framebuffer`] (trait.ContextFramebufferBuilderExt.html#method.build_framebuffer) method.",null,null],[3,"FramebufferBinding","","Represents a framebuffer that has been bound to the `GL_FRAMEBUFFER` binding target.",null,null],[3,"FramebufferBinder","","The OpenGL state representing the `GL_FRAMEBUFFER` target.",null,null],[4,"FramebufferTarget","","All of the possible OpenGL targets for binding framebuffer objects.",null,null],[13,"Framebuffer","","The lone framebuffer target.",10,null],[4,"FramebufferAttachment","","The various attachment points of a framebuffer object.",null,null],[13,"ColorAttachment0","","The color buffer attachment point.",11,null],[13,"DepthAttachment","","The depth buffer attachment point.",11,null],[13,"StencilAttachment","","The stencil buffer attachment point.",11,null],[17,"FRAMEBUFFER","","The lone framebuffer target.",null,null],[17,"COLOR_ATTACHMENT0","","The color buffer attachment point.",null,null],[17,"DEPTH_ATTACHMENT","","The depth buffer attachment point.",null,null],[17,"STENCIL_ATTACHMENT","","The stencil buffer attachment point.",null,null],[8,"ContextFramebufferExt","","An extension trait that includes framebuffer-related OpenGL methods.",null,null],[11,"gen_framebuffer","","Create a new framebuffer object with no attachments.",12,{"inputs":[{"name":"self"}],"output":{"name":"framebuffer"}}],[11,"check_framebuffer_status","","Returns the status of any framebuffer-completeness errors of a currently-bound framebuffer object. Returns `None` if the framebuffer is framebuffer-complete.",12,{"inputs":[{"name":"self"},{"name":"framebufferbinding"}],"output":{"name":"option"}}],[11,"framebuffer_renderbuffer","","Attach a renderbuffer object to a framebuffer object's attachment point.",12,{"inputs":[{"name":"self"},{"name":"framebufferbinding"},{"name":"framebufferattachment"},{"name":"renderbuffer"}],"output":null}],[11,"framebuffer_texture_2d","","Attach a texture to a framebuffer object's attachment point.",12,{"inputs":[{"name":"self"},{"name":"framebufferbinding"},{"name":"framebufferattachment"},{"name":"i"},{"name":"texture"},{"name":"i32"}],"output":null}],[11,"clear","","Clear the currently-bound drawing buffers that are specified by the `buffers` argument.",12,{"inputs":[{"name":"self"},{"name":"bufferbits"}],"output":null}],[8,"ContextFramebufferBuilderExt","","The extension trait for contexts that adds the `build_framebuffer` method. This trait is only implemented for contexts that have a free framebuffer binding.",null,null],[11,"build_framebuffer","","Create a new framebuffer builder, providing a safe interface for constructing a framebuffer object. See the [`FramebufferBuilder`] (struct.FramebufferBuilder.html) docs for more details.",13,{"inputs":[{"name":"self"}],"output":{"name":"framebufferbuilder"}}],[8,"FramebufferContext","","An OpenGL context that has a free `GL_FRAMEBUFFER` binding.",null,null],[16,"Binder","","The type of binder this context contains.",14,null],[16,"Rest","","The OpenGL context that will be returned after binding a framebuffer.",14,null],[10,"split_framebuffer","","Split the context into a binder and the remaining context.",14,null],[11,"bind_framebuffer","","Bind a buffer to this context's framebuffer, returning a new context and a binding.",14,null],[11,"texture_2d","","Add a 2D texture (at the mipmap level specified by `level`) to the framebuffer's attachment point.",15,{"inputs":[{"name":"self"},{"name":"framebufferattachment"},{"name":"texture2d"},{"name":"i32"}],"output":{"name":"self"}}],[11,"renderbuffer","","Add a renderbuffer to the framebuffer's attachment point.",15,{"inputs":[{"name":"self"},{"name":"framebufferattachment"},{"name":"renderbuffer"}],"output":{"name":"self"}}],[11,"try_unwrap","","Create and return a framebuffer with the specified options, or return an error.",15,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"unwrap","","Create and return a framebuffer with the specified options, or panic.",15,{"inputs":[{"name":"self"}],"output":{"name":"framebuffer"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"framebuffertarget"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"framebuffertarget"}],"output":{"name":"bool"}}],[11,"hash","","",10,null],[11,"from_gl","","Convert from a raw OpenGL integer value to an enum variant. Returns an error if the value is not a valid enum variant.",10,{"inputs":[{"name":"glenum"}],"output":{"name":"result"}}],[11,"gl_enum","","Return the OpenGL integer value for a given enum variant.",10,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"framebufferattachment"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"framebufferattachment"}],"output":{"name":"bool"}}],[11,"hash","","",11,null],[11,"from_gl","","Convert from a raw OpenGL integer value to an enum variant. Returns an error if the value is not a valid enum variant.",11,{"inputs":[{"name":"glenum"}],"output":{"name":"result"}}],[11,"gl_enum","","Return the OpenGL integer value for a given enum variant.",11,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[11,"split_framebuffer","glitter::context","",4,null],[11,"current","glitter::context::framebuffer_context","Get the current `GL_FRAMEBUFFER` binder.",16,{"inputs":[],"output":{"name":"self"}}],[11,"current_binding","","Get the current `GL_FRAMEBUFFER` binding.",16,{"inputs":[{"name":"self"}],"output":{"name":"framebufferbinding"}}],[11,"bind","","Bind a framebuffer to the `GL_FRAMEBUFFER` target, returning a binding.",16,{"inputs":[{"name":"self"},{"name":"framebuffer"}],"output":{"name":"framebufferbinding"}}],[0,"program_context","glitter::context","Contains all of the OpenGL state types related to shader programs.",null,null],[3,"ProgramBuilder","glitter::context::program_context","Provides a safe interface for creating program objects. A `ProgramBuilder` can be created using the [`gl.build_program`] (trait.ContextProgramBuilderExt.html#method.build_program) method.",null,null],[3,"ProgramBinding","","Represents a program that has been bound to the context.",null,null],[3,"ProgramBinder","","The OpenGL state representing the active program target.",null,null],[3,"UnknownProgramAttrib","","An error that represents a program attribute that could not be found.",null,null],[3,"UnknownProgramUniform","","An error that represents a program uniform that could not be found.",null,null],[8,"ContextProgramBuilderExt","","The extension trait that adds the `build_program` method.",null,null],[11,"build_program","","Create a new program builder, providing a safe interface for constructing a program object. See the [`ProgramBuilder`] (struct.ProgramBuilder.html) docs for more details.",17,null],[8,"ContextProgramExt","","An extension trait that includes program-related OpenGL methods.",null,null],[11,"create_program","","Create a new program object that has no shaders attached, or return an error if a shader object could not be created.",18,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"attach_shader","","Attach a shader to a program object.",18,{"inputs":[{"name":"self"},{"name":"program"},{"name":"shader"}],"output":null}],[11,"link_program","","Link the program object, so that it can be used for rendering. Returns an error if the program could not be linked.",18,{"inputs":[{"name":"self"},{"name":"program"}],"output":{"name":"result"}}],[11,"get_program_info_log","","Return the information log for the program object, if any is available.",18,{"inputs":[{"name":"self"},{"name":"program"}],"output":{"name":"option"}}],[11,"get_attrib_location","","Retrieve a program attribute's index by name, or return an error if the attribute was not found in the program.",18,{"inputs":[{"name":"self"},{"name":"program"},{"name":"str"}],"output":{"name":"result"}}],[11,"get_uniform_location","","Retrieve a program uniform's index by name, or return an error if the uniform was not found within the program.",18,{"inputs":[{"name":"self"},{"name":"program"},{"name":"str"}],"output":{"name":"result"}}],[11,"set_uniform","","Set the value of a uniform variable within the provided program object binding.",18,{"inputs":[{"name":"self"},{"name":"programbinding"},{"name":"programuniform"},{"name":"t"}],"output":null}],[8,"ProgramContext","","An OpenGL context that has a free program binding.",null,null],[16,"Binder","","The type of binder this context contains.",19,null],[16,"Rest","","The OpenGL context that will be returned after binding a program.",19,null],[10,"split_program","","Split the context into a binder and the remaining context.",19,null],[11,"use_program","","Bind a program to this context's program, returning a new context and a binding.",19,null],[11,"new","","Create a new program builder.",20,null],[11,"try_unwrap","","Create and link the program object with the provided shaders, or return an error.",20,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"unwrap","","Create and link the program object with the provided shaders, or panic.",20,{"inputs":[{"name":"self"}],"output":{"name":"program"}}],[11,"split_program","glitter::context","",4,null],[11,"current","glitter::context::program_context","Get the current program binder.",21,{"inputs":[],"output":{"name":"self"}}],[11,"bind","","Bind a program to the context, returning a binding.",21,{"inputs":[{"name":"self"},{"name":"program"}],"output":{"name":"programbinding"}}],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",22,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"fmt","","",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",23,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[0,"renderbuffer_context","glitter::context","Contains all of the OpenGL state types related to renderbuffers.",null,null],[3,"RenderbufferBuilder","glitter::context::renderbuffer_context","Provides a safe wrapper for creating renderbuffer objects. A `RenderbufferBuilder` can be created using the [`gl.build_renderbuffer`] (trait.ContextRenderbufferBuilderExt.html#method.build_renderbuffer) method.",null,null],[3,"RenderbufferBinding","","Represents a renderbuffer that has been bound to the `GL_RENDERBUFFER` binding target.",null,null],[3,"RenderbufferBinder","","The OpenGL state representing the `GL_RENDERBUFFER` target.",null,null],[8,"ContextRenderbufferBuilderExt","","The extension trait for contexts that adds the `build_renderbuffer` method. This trait is only implemented for contexts with a free renderbuffer binding.",null,null],[11,"build_renderbuffer","","Create a new renderbuffer builder, providing a safe interface for constructing a renderbuffer object. See the [`RenderbufferBuilder`] (struct.RenderbufferBuilder.html) docs for more details.",24,{"inputs":[{"name":"self"}],"output":{"name":"renderbufferbuilder"}}],[8,"ContextRenderbufferExt","","An extension trait that includes renderbuffer-related OpenGL methods.",null,null],[11,"gen_renderbuffer","","Create a new renderbuffer object with no storage allocated.",25,{"inputs":[{"name":"self"}],"output":{"name":"renderbuffer"}}],[11,"storage","","Initialize a renderbuffer object's storage.",25,{"inputs":[{"name":"self"},{"name":"renderbufferbinding"},{"name":"renderbufferformat"},{"name":"u32"},{"name":"u32"}],"output":null}],[8,"RenderbufferContext","","An OpenGL context that has a free `GL_RENDERBUFFER` binding.",null,null],[16,"Binder","","The type of binder this context contains.",26,null],[16,"Rest","","The OpenGL context that will be returned after binding a renderbuffer.",26,null],[10,"split_renderbuffer","","Split the context into a binder and the remaining context.",26,null],[11,"bind_renderbuffer","","Bind a renderbuffer to this context's renderbuffer, returning a new context and a binding.",26,null],[11,"storage","","Set the storage parameters for the renderbuffer.",27,{"inputs":[{"name":"self"},{"name":"renderbufferformat"},{"name":"u32"},{"name":"u32"}],"output":{"name":"self"}}],[11,"try_unwrap","","Create and return a renderbuffer with the provided storage options, or return an error.",27,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"unwrap","","Create a renderbuffer with the provided storage options, or panic.",27,{"inputs":[{"name":"self"}],"output":{"name":"renderbuffer"}}],[11,"split_renderbuffer","glitter::context","",4,null],[11,"current","glitter::context::renderbuffer_context","Get the current `GL_RENDERBUFFER` binder.",28,{"inputs":[],"output":{"name":"self"}}],[11,"bind","","Bind a renderbuffer to the `GL_RENDERBUFFER` target, returning a binding.",28,{"inputs":[{"name":"self"},{"name":"renderbuffer"}],"output":{"name":"renderbufferbinding"}}],[0,"texture_context","glitter::context","Contains all of the OpenGL state types related to texture bindings.",null,null],[3,"Texture2dBuilder","glitter::context::texture_context","Provide a safe interface for building a 2D texture object that is checked to be complete. A `Texture2dBuilder` can be created using the [`gl.build_texture_2d`] (trait.ContextTextureBuilderExt.html#method.build_texture_2d) method.",null,null],[3,"Texture2dBinding","","Represents a texture that has been bound to the `GL_TEXTURE_2D` binding target of a texture unit.",null,null],[3,"TextureCubeMapBinding","","Represents a texture that has been bound to the `GL_TEXTURE_CUBE_MAP` binding target of a texture unit.",null,null],[3,"Texture2dBinder","","The OpenGL texture unit state that represents the `GL_TEXTURE_2D` target.",null,null],[3,"TextureCubeMapBinder","","The OpenGL texture unit state that represents the `GL_TEXTURE_CUBE_MAP` target.",null,null],[8,"ContextTextureBuilderExt","","The extension trait for contexts that adds the `build_texture_2d` method.",null,null],[11,"build_texture_2d","","Create a new 2D texture builder, providing a safe interface for constructing a 2D texture object. See the [`Texture2dBuilder`] (struct.Texture2dBuilder.html) docs for more details.",29,{"inputs":[{"name":"self"}],"output":{"name":"texture2dbuilder"}}],[8,"ContextTextureExt","","An extension trait that includes texture-related OpenGL methods.",null,null],[11,"gen_texture","","Create a new texture with no storage or image data.",30,{"inputs":[{"name":"self"}],"output":{"name":"texture"}}],[11,"set_min_filter","","Set a texture's minifying filter.",30,{"inputs":[{"name":"self"},{"name":"t"},{"name":"f"}],"output":null}],[11,"set_mag_filter","","Set a texture's magnifying filter.",30,{"inputs":[{"name":"self"},{"name":"t"},{"name":"texturefilter"}],"output":null}],[11,"set_wrap_s","","Set a texture's wrap mode for the s-coordinate.",30,{"inputs":[{"name":"self"},{"name":"t"},{"name":"texturewrapmode"}],"output":null}],[11,"set_wrap_t","","Set a texture's wrap mode for the t-coordinate.",30,{"inputs":[{"name":"self"},{"name":"t"},{"name":"texturewrapmode"}],"output":null}],[11,"generate_mipmap","","Generate a set of mipmaps for a texture object.",30,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"tex_image_2d","","Upload 2D image data to a texture object's image target.",30,{"inputs":[{"name":"self"},{"name":"t"},{"name":"u"},{"name":"u32"},{"name":"i"}],"output":null}],[11,"tex_image_2d_empty","","Set a texture object's image target to an empty image with the specified parameters.",30,{"inputs":[{"name":"self"},{"name":"t"},{"name":"i"},{"name":"u32"},{"name":"imageformat"},{"name":"u32"},{"name":"u32"}],"output":null}],[8,"TextureBinding","","Represents a texture that has been bound to a texture unit.",null,null],[16,"TextureType","","The type of texture that this binding represents.",31,null],[10,"target","","The OpenGL texture target of this binding.",31,{"inputs":[{"name":"self"}],"output":{"name":"texturebindingtarget"}}],[11,"image_2d","","Set the 2D image data to fill the texture with.",32,{"inputs":[{"name":"self"},{"name":"image2d"}],"output":{"name":"self"}}],[11,"empty","","Set the parameters for creating an empty texture.",32,{"inputs":[{"name":"self"},{"name":"imageformat"},{"name":"u32"},{"name":"u32"}],"output":{"name":"self"}}],[11,"generate_mipmap","","Automatically generate mipmaps for the texture.",32,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"min_filter","","Set the texture's minifying filter.",32,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"self"}}],[11,"mag_filter","","Set the texture's magnifying filter.",32,{"inputs":[{"name":"self"},{"name":"texturefilter"}],"output":{"name":"self"}}],[11,"wrap_s","","Set the texture's wrap mode for the s-coordinate.",32,{"inputs":[{"name":"self"},{"name":"texturewrapmode"}],"output":{"name":"self"}}],[11,"wrap_t","","Set the texture's wrap mode for the t-coordinate.",32,{"inputs":[{"name":"self"},{"name":"texturewrapmode"}],"output":{"name":"self"}}],[11,"try_unwrap","","Create and return a texture with the specified options, or return an error.",32,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"unwrap","","Create a texture with the specified options, or panic.",32,{"inputs":[{"name":"self"}],"output":{"name":"texture2d"}}],[11,"target","","",33,{"inputs":[{"name":"self"}],"output":{"name":"texturebindingtarget"}}],[11,"target","","",34,{"inputs":[{"name":"self"}],"output":{"name":"texturebindingtarget"}}],[11,"current","","Get the current `GL_TEXTURE_2D` binder.",35,{"inputs":[],"output":{"name":"self"}}],[11,"bind","","Bind a texture to the `GL_TEXTURE_2D` target, returning a binding.",35,{"inputs":[{"name":"self"},{"name":"texture2d"}],"output":{"name":"texture2dbinding"}}],[11,"current","","Get the current `GL_TEXTURE_CUBE_MAP` binder.",36,{"inputs":[],"output":{"name":"self"}}],[11,"bind","","Bind a texture to the `GL_TEXTURE_CUBE_MAP` target, returning a binding.",36,{"inputs":[{"name":"self"},{"name":"texturecubemap"}],"output":{"name":"texturecubemapbinding"}}],[0,"texture_units","glitter::context","Contains all of the OpenGL state types related texture units.",null,null],[3,"TextureUnit0","glitter::context::texture_units","The 0th texture unit.",null,null],[3,"TextureUnit1","","The 1st texture unit.",null,null],[3,"TextureUnit2","","The 2nd texture unit.",null,null],[3,"TextureUnit3","","The 3rd texture unit.",null,null],[3,"TextureUnit4","","The 4th texture unit.",null,null],[3,"TextureUnit5","","The 5th texture unit.",null,null],[3,"TextureUnit6","","The 6th texture unit.",null,null],[3,"TextureUnit7","","The 7th texture unit.",null,null],[3,"TextureUnitsOf","","This type holds all of the OpenGL texture units. Each type parameter is the current type of a texture unit. See the [`ContextOf`] (../struct.ContextOf.html) docs for more details.",null,null],[12,"0","","",37,null],[12,"1","","",37,null],[12,"2","","",37,null],[12,"3","","",37,null],[12,"4","","",37,null],[12,"5","","",37,null],[12,"6","","",37,null],[12,"7","","",37,null],[3,"TextureUnitBindingOf","","A texture unit that has been made active, and can have textures bound to it.",null,null],[3,"TextureSampler","","A newtype wrapper representing a texture sampler, which can be used to set a uniform variable, using [`gl.set_uniform`] (../program_context/trait.ContextProgramExt.html#method.set_uniform).",null,null],[6,"TextureUnits","","A part of the OpenGL context that has all free texture units.",null,null],[6,"TextureUnitBinding","","A fresh texture unit binding, that has all free texture bindings.",null,null],[8,"TextureUnit","","A trait that represents a 'texture unit', which is a piece of OpenGL state that contains its own independent texture bindings.",null,null],[10,"idx","","Get the index of the texture unit.",38,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"active","","Make the current texture unit active, returning a binding.",38,{"inputs":[{"name":"self"}],"output":{"name":"textureunitbinding"}}],[8,"TextureUnit0Context","","An OpenGL context with the 0th texture unit free.",null,null],[16,"Unit","","The type of unit this context contains.",39,null],[16,"Rest","","The OpenGL context that will be returned after making the texture unit active.",39,null],[10,"split_tex_unit_0","","Split the 0th texture unit from the context, returning the unit and the remaining context.",39,null],[11,"active_texture_0","","Make the 0th texture unit active, returning a binding and the remaining context",39,null],[8,"TextureUnit1Context","","An OpenGL context with the 1st texture unit free.",null,null],[16,"Unit","","The type of unit this context contains.",40,null],[16,"Rest","","The OpenGL context that will be returned after making the texture unit active.",40,null],[10,"split_tex_unit_1","","Split the 1st texture unit from the context, returning the unit and the remaining context.",40,null],[11,"active_texture_1","","Make the 1st texture unit active, returning a binding and the remaining context",40,null],[8,"TextureUnit2Context","","An OpenGL context with the 2nd texture unit free.",null,null],[16,"Unit","","The type of unit this context contains.",41,null],[16,"Rest","","The OpenGL context that will be returned after making the texture unit active.",41,null],[10,"split_tex_unit_2","","Split the 2nd texture unit from the context, returning the unit and the remaining context.",41,null],[11,"active_texture_2","","Make the 2nd texture unit active, returning a binding and the remaining context",41,null],[8,"TextureUnit3Context","","An OpenGL context with the 3rd texture unit free.",null,null],[16,"Unit","","The type of unit this context contains.",42,null],[16,"Rest","","The OpenGL context that will be returned after making the texture unit active.",42,null],[10,"split_tex_unit_3","","Split the 3rd texture unit from the context, returning the unit and the remaining context.",42,null],[11,"active_texture_3","","Make the 3rd texture unit active, returning a binding and the remaining context",42,null],[8,"TextureUnit4Context","","An OpenGL context with the 4th texture unit free.",null,null],[16,"Unit","","The type of unit this context contains.",43,null],[16,"Rest","","The OpenGL context that will be returned after making the texture unit active.",43,null],[10,"split_tex_unit_4","","Split the 4th texture unit from the context, returning the unit and the remaining context.",43,null],[11,"active_texture_4","","Make the 4th texture unit active, returning a binding and the remaining context",43,null],[8,"TextureUnit5Context","","An OpenGL context with the 5th texture unit free.",null,null],[16,"Unit","","The type of unit this context contains.",44,null],[16,"Rest","","The OpenGL context that will be returned after making the texture unit active.",44,null],[10,"split_tex_unit_5","","Split the 5th texture unit from the context, returning the unit and the remaining context.",44,null],[11,"active_texture_5","","Make the 5th texture unit active, returning a binding and the remaining context",44,null],[8,"TextureUnit6Context","","An OpenGL context with the 6th texture unit free.",null,null],[16,"Unit","","The type of unit this context contains.",45,null],[16,"Rest","","The OpenGL context that will be returned after making the texture unit active.",45,null],[10,"split_tex_unit_6","","Split the 6th texture unit from the context, returning the unit and the remaining context.",45,null],[11,"active_texture_6","","Make the 6th texture unit active, returning a binding and the remaining context",45,null],[8,"TextureUnit7Context","","An OpenGL context with the 7th texture unit free.",null,null],[16,"Unit","","The type of unit this context contains.",46,null],[16,"Rest","","The OpenGL context that will be returned after making the texture unit active.",46,null],[10,"split_tex_unit_7","","Split the 7th texture unit from the context, returning the unit and the remaining context.",46,null],[11,"active_texture_7","","Make the 7th texture unit active, returning a binding and the remaining context",46,null],[8,"ATextureUnitBinding","","A marker trait for types that represent an active texture unit binding.",null,null],[8,"TextureUnitBinding2d","","A texture unit binding that has a free `GL_TEXTURE_2D` binding.",null,null],[16,"Binder","","The type of binder this texture unit contains.",47,null],[16,"Rest","","The texture unit that will be returned after binding the texture.",47,null],[10,"split_texture_2d","","Split the texture unit into a binder and the remaining texture unit.",47,null],[11,"bind_texture_2d","","Bind a 2D texture to this texture unit, returning a binding and the remaining texture unit.",47,null],[8,"TextureUnitBindingCubeMap","","A texture unit binding that has a free `GL_TEXTURE_CUBE_MAP` binding.",null,null],[16,"Binder","","The type of binder this texture unit contains.",48,null],[16,"Rest","","The texture unit that will be returned after binding the texture.",48,null],[10,"split_texture_cube_map","","Split the texture unit into a binder and the remaining texture unit.",48,null],[11,"bind_texture_cube_map","","Bind a cubemap texture to this texture unit, returning a binding and the remaining texture unit.",48,null],[11,"idx","","",49,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"idx","","",50,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"idx","","",51,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"idx","","",52,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"idx","","",53,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"idx","","",54,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"idx","","",55,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"idx","","",56,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"current","","Get the current texture units.",37,{"inputs":[],"output":{"name":"textureunits"}}],[11,"swap_0","","Replace the 0th texture unit context with a new value, returning the old value and a new set of texture units",37,null],[11,"swap_1","","Replace the 1st texture unit context with a new value, returning the old value and a new set of texture units",37,null],[11,"swap_2","","Replace the 2nd texture unit context with a new value, returning the old value and a new set of texture units",37,null],[11,"swap_3","","Replace the 3rd texture unit context with a new value, returning the old value and a new set of texture units",37,null],[11,"swap_4","","Replace the 4th texture unit context with a new value, returning the old value and a new set of texture units",37,null],[11,"swap_5","","Replace the 5th texture unit context with a new value, returning the old value and a new set of texture units",37,null],[11,"swap_6","","Replace the 6th texture unit context with a new value, returning the old value and a new set of texture units",37,null],[11,"swap_7","","Replace the 7th texture unit context with a new value, returning the old value and a new set of texture units",37,null],[11,"active_nth","","Make the `idx`th texture unit the active one, returning a new binding.",37,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"textureunitbinding"}}],[11,"split_tex_unit_0","glitter::context","",4,null],[11,"split_tex_unit_1","","",4,null],[11,"split_tex_unit_2","","",4,null],[11,"split_tex_unit_3","","",4,null],[11,"split_tex_unit_4","","",4,null],[11,"split_tex_unit_5","","",4,null],[11,"split_tex_unit_6","","",4,null],[11,"split_tex_unit_7","","",4,null],[11,"gl_idx","glitter::context::texture_units","Get the index of the texture unit.",57,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"sampler","","Get the current texture unit as a [`TextureSampler`] (struct.TextureSampler.html), which can be used to set a uniform variable.",57,{"inputs":[{"name":"self"}],"output":{"name":"texturesampler"}}],[11,"split_texture_2d","","",57,null],[11,"split_texture_cube_map","","",57,null],[11,"fmt","","",58,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",58,{"inputs":[{"name":"self"}],"output":{"name":"texturesampler"}}],[11,"uniform_datum_type","","",58,{"inputs":[],"output":{"name":"uniformdatumtype"}}],[0,"ext","glitter::context","Contains all of the `ContextOf` extension traits that implement core OpenGL functionality.",null,null],[6,"Context","","A \"fresh\" OpenGL context: one that essentially has no active bindings. See the `ContextOf` docs for more details.",null,null],[8,"BaseContext","","A marker trait for types that represent an active OpenGL context.",null,null],[8,"ContextExt","","An extension trait that contains some of the core OpenGL methods that maintain state, such as the current clear color or whether depth testing is enabled.",null,null],[11,"clear_color","","Set the clear value when clearing a color buffer with [`gl.clear(glitter::COLOR_BUFFER_BIT)`] (framebuffer_context/trait.ContextFramebufferExt.html#method.clear).",59,{"inputs":[{"name":"self"},{"name":"color"}],"output":null}],[11,"enable","","Enable an OpenGL capability.",59,{"inputs":[{"name":"self"},{"name":"capability"}],"output":null}],[11,"disable","","Disable an OpenGL capability.",59,{"inputs":[{"name":"self"},{"name":"capability"}],"output":null}],[11,"enable_vertex_attrib_array","","Enable the vertex attribute array to be used while drawing with `gl.draw_arrays_range`, `gl.draw_elements`, `gl.draw_n_elements`, `gl.draw_n_elements_buffered`.",59,{"inputs":[{"name":"self"},{"name":"programattrib"}],"output":null}],[11,"viewport","","Set the OpenGL viewport dimensions, which maps from device coordinates to window coordinates.",59,{"inputs":[{"name":"self"},{"name":"viewport"}],"output":null}],[8,"AContext","","The 'core' OpenGL context trait. This trait provides access to any OpenGL functionality that don't deal with binding. This trait is implemented for `ContextOf<_, _, _, _, _>`, as well as for `&mut ContextOf<_, _, _, _, _>`.",null,null],[11,"load_with","","Use a function to load OpenGL function pointers. This function must be called before calling [`ContextOf::current_context`] (struct.ContextOf.html#method.current_context).",4,{"inputs":[{"name":"l"}],"output":null}],[11,"current_context","","Get the current OpenGL context.",4,{"inputs":[],"output":{"name":"context"}}],[11,"get_error","","Get an OpenGL error that was generated since the last call to `ContextOf::get_error()`, or `None` is none occurred.",4,{"inputs":[],"output":{"name":"option"}}],[11,"borrowed","","Return a new `ContextOf`, where the type parameters of the new context are borrows of the current context. This function shouldn't be necessary in most circumstances, and will likely be removed from the public API in a future release.",4,{"inputs":[{"name":"self"}],"output":{"name":"contextof"}}],[11,"borrowed_mut","","Return a new `ContextOf`, where the type parameters of the new context are mutable borrows of the current context. This function shouldn't be necessary in most circumstances, and will likely be removed from the public API in a future release.",4,{"inputs":[{"name":"self"}],"output":{"name":"contextof"}}],[11,"swap_buffers","","Replace the current context's internal `buffers` field (of type `B`) with a new value, returning the old value and a new context. This function will likely be removed from the public API in the future.",4,null],[11,"swap_framebuffer","","Replace the current context's internal `framebuffer` field (of type `F`) with a new value, returning the old value and a new context. This function will likely be removed from the public API in the future.",4,null],[11,"swap_program","","Replace the current context's internal `program` field (of type `P`) with a new value, returning the old value and a new context. This function will likely be removed from the public API in the future.",4,null],[11,"swap_renderbuffer","","Replace the current context's internal `renderbuffer` field (of type `B`) with a new value, returning a new context and the old value. This function will likely be removed from the public API in the future.",4,null],[11,"swap_tex_units","","Replace the current context's internal `tex_units` field (of type `T`) with a new value, returning the old value and a new context. This function will likely be removed from the public API in the future.",4,null],[0,"buffer","glitter","Exposes the OpenGL `Buffer` object, and related types.",null,null],[3,"Buffer","glitter::buffer","An OpenGL buffer object.",null,null],[4,"BufferDataUsage","","Provides a hint to the OpenGL driver for how a buffer will be used.",null,null],[13,"StreamDraw","","Indicates that a buffer will be set once and drawn only a few times.",60,null],[13,"StaticDraw","","Indicates that a buffer will be set once and drawn many times",60,null],[13,"DynamicDraw","","Indicates that a buffer will be set and modified repeatedly and drawn many times.",60,null],[4,"BufferBindingTarget","","All of the possible OpenGL targets for binding a buffer object.",null,null],[13,"ArrayBuffer","","The array buffer object binding.",61,null],[13,"ElementArrayBuffer","","The element array buffer object binding.",61,null],[17,"STREAM_DRAW","","Indicates that a buffer will be set once and drawn only a few times.",null,null],[17,"STATIC_DRAW","","Indicates that a buffer will be set once and drawn many times",null,null],[17,"DYNAMIC_DRAW","","Indicates that a buffer will be set and modified repeatedly and drawn many times.",null,null],[17,"ARRAY_BUFFER","","The array buffer object binding.",null,null],[17,"ELEMENT_ARRAY_BUFFER","","The element array buffer object binding.",null,null],[11,"drop","","",62,{"inputs":[{"name":"self"}],"output":null}],[11,"from_raw","","",62,null],[11,"id","","",62,null],[11,"fmt","","",60,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",60,{"inputs":[{"name":"self"}],"output":{"name":"bufferdatausage"}}],[11,"eq","","",60,{"inputs":[{"name":"self"},{"name":"bufferdatausage"}],"output":{"name":"bool"}}],[11,"hash","","",60,null],[11,"from_gl","","Convert from a raw OpenGL integer value to an enum variant. Returns an error if the value is not a valid enum variant.",60,{"inputs":[{"name":"glenum"}],"output":{"name":"result"}}],[11,"gl_enum","","Return the OpenGL integer value for a given enum variant.",60,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[11,"fmt","","",61,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",61,{"inputs":[{"name":"self"}],"output":{"name":"bufferbindingtarget"}}],[11,"eq","","",61,{"inputs":[{"name":"self"},{"name":"bufferbindingtarget"}],"output":{"name":"bool"}}],[11,"hash","","",61,null],[11,"from_gl","","Convert from a raw OpenGL integer value to an enum variant. Returns an error if the value is not a valid enum variant.",61,{"inputs":[{"name":"glenum"}],"output":{"name":"result"}}],[11,"gl_enum","","Return the OpenGL integer value for a given enum variant.",61,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[0,"shader","glitter","Exposes the OpenGL `Shader` object and related types.",null,null],[3,"Shader","glitter::shader","An OpenGL shader object.",null,null],[3,"ShaderBuilder","","A safe interface for creating a shader with a source, and returning an error or panicking if there is an error.",null,null],[4,"ShaderType","","The possible types of shader objects.",null,null],[13,"VertexShader","","A shader that is used for processing per-vertex data.",63,null],[13,"FragmentShader","","A shader that is used for processing per-fragment (per-pixel) data.",63,null],[17,"VERTEX_SHADER","","A shader that is used for processing per-vertex data.",null,null],[17,"FRAGMENT_SHADER","","A shader that is used for processing per-fragment (per-pixel) data.",null,null],[8,"ContextShaderBuilderExt","","An extension trait for `ContextOf` that adds functions to build shaders using the [`ShaderBuilder`] (struct.ShaderBuilder.html) interface.",null,null],[10,"build_shader","","Build a new shader with the provided shader type and shader source.",64,{"inputs":[{"name":"self"},{"name":"shadertype"},{"name":"str"}],"output":{"name":"shaderbuilder"}}],[11,"build_fragment_shader","","Build a new fragment shader with the provided shader source.",64,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"shaderbuilder"}}],[11,"build_vertex_shader","","Build a new vertex shader with the provided shader source.",64,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"shaderbuilder"}}],[8,"ContextShaderExt","","An extension trait that includes shader-related OpenGL methods.",null,null],[11,"create_shader","","Create a new, uninitialized shader.",65,{"inputs":[{"name":"self"},{"name":"shadertype"}],"output":{"name":"result"}}],[11,"shader_source","","Set or replace a shader object's source. The shader should be recompiled after calling this function by using the [`gl.compile_shader`] (trait.ContextShaderExt.html#method.compile_shader) function",65,{"inputs":[{"name":"self"},{"name":"shader"},{"name":"str"}],"output":null}],[11,"compile_shader","","Compile the shader's associated source.",65,{"inputs":[{"name":"self"},{"name":"shader"}],"output":{"name":"result"}}],[11,"get_shader_info_log","","Get the information log associated with a shader. This is used to get compilation errors, warnings, or other diagnostic information that may have occurred while trying to compile a shader. Returns `None` if no such diagnostic information was generated.",65,{"inputs":[{"name":"self"},{"name":"shader"}],"output":{"name":"option"}}],[11,"drop","","",66,{"inputs":[{"name":"self"}],"output":null}],[11,"from_raw","","",66,null],[11,"id","","",66,null],[11,"try_unwrap","","Try to compile a shader with the provided options, or `Err` if a new shader object could not be created or if there was an error compiling the provided source.",67,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"unwrap","","Try to compile a shader with the provided options, panicking if a new shader object could not be created or if there was an error compiling the provided source.",67,{"inputs":[{"name":"self"}],"output":{"name":"shader"}}],[11,"fmt","","",63,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",63,{"inputs":[{"name":"self"}],"output":{"name":"shadertype"}}],[11,"eq","","",63,{"inputs":[{"name":"self"},{"name":"shadertype"}],"output":{"name":"bool"}}],[11,"hash","","",63,null],[11,"from_gl","","Convert from a raw OpenGL integer value to an enum variant. Returns an error if the value is not a valid enum variant.",63,{"inputs":[{"name":"glenum"}],"output":{"name":"result"}}],[11,"gl_enum","","Return the OpenGL integer value for a given enum variant.",63,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[0,"program","glitter","Exposes the OpenGL `Program` object and related types.",null,null],[3,"Program","glitter::program","An OpenGL program object.",null,null],[3,"ProgramAttrib","","An OpenGL generic vertex attribute.",null,null],[12,"gl_index","","The index of the program attribute.",68,null],[3,"ProgramUniform","","An OpenGL program uniform.",null,null],[12,"gl_index","","The index of the the program uniform.",69,null],[11,"drop","","",70,{"inputs":[{"name":"self"}],"output":null}],[11,"from_raw","","",70,null],[11,"id","","",70,null],[11,"fmt","","",68,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",68,{"inputs":[{"name":"self"}],"output":{"name":"programattrib"}}],[11,"fmt","","",69,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",69,{"inputs":[{"name":"self"}],"output":{"name":"programuniform"}}],[0,"framebuffer","glitter","Exposes the OpenGL `Framebuffer` object, and related types.",null,null],[3,"Framebuffer","glitter::framebuffer","An OpenGL framebuffer object.",null,null],[11,"drop","","",71,{"inputs":[{"name":"self"}],"output":null}],[11,"from_raw","","",71,null],[11,"id","","",71,null],[0,"renderbuffer","glitter","Exposes the OpenGL `Renderbuffer` object, and related types.",null,null],[3,"Renderbuffer","glitter::renderbuffer","An OpenGL renderbuffer object.",null,null],[4,"RenderbufferTarget","","All of the possible OpenGL targets for binding renderbuffer objects.",null,null],[13,"Renderbuffer","","The lone renderbuffer target.",72,null],[17,"RENDERBUFFER","","The lone renderbuffer target.",null,null],[11,"drop","","",73,{"inputs":[{"name":"self"}],"output":null}],[11,"from_raw","","",73,null],[11,"id","","",73,null],[11,"fmt","","",72,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",72,{"inputs":[{"name":"self"}],"output":{"name":"renderbuffertarget"}}],[11,"eq","","",72,{"inputs":[{"name":"self"},{"name":"renderbuffertarget"}],"output":{"name":"bool"}}],[11,"hash","","",72,null],[11,"from_gl","","Convert from a raw OpenGL integer value to an enum variant. Returns an error if the value is not a valid enum variant.",72,{"inputs":[{"name":"glenum"}],"output":{"name":"result"}}],[11,"gl_enum","","Return the OpenGL integer value for a given enum variant.",72,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[0,"texture","glitter","Exposes the OpenGL `Texture` family of objects and related types.",null,null],[3,"Texture","glitter::texture","A type of OpenGL texture.",null,null],[3,"Tx2d","","The `TextureType` for 2-dimensional textures.",null,null],[3,"TxCubeMap","","The `TextureType` for cubemap textures.",null,null],[3,"VariantTexture2d","","This is a unit type that is used to be coerced into select enum variants.",null,null],[4,"Tx2dImageTarget","","The possible image targets for `GL_TEXTURE_2D` (only one variant, since this is the 2D texture).",null,null],[13,"Texture2d","","The only possible target for a 2-dimensional texture.",74,null],[4,"TxCubeMapImageTarget","","The possible 2D image targets for a cubemap texture.",null,null],[13,"CubeMapPositiveX","","The positive-X image target face of a cubemap.",75,null],[13,"CubeMapNegativeX","","The negative-X image target face of a cubemap.",75,null],[13,"CubeMapPositiveY","","The positive-Y image target face of a cubemap.",75,null],[13,"CubeMapNegativeY","","The negative-Y image target face of a cubemap.",75,null],[13,"CubeMapPositiveZ","","The positive-Z image target face of a cubemap.",75,null],[13,"CubeMapNegativeZ","","The negative-Z image target face of a cubemap.",75,null],[4,"TextureBindingTarget","","Represents all of the possible types of OpenGL textures.",null,null],[13,"Texture2d","","A 2-dimensional texture, which can be thought of as a 2D grid of colors.",76,null],[13,"TextureCubeMap","","A cubemap texture, which is a texture made up of six 2-dimensional images, each of which represent a face of a cube. This type of texture is especially useful for skyboxes.",76,null],[4,"TextureFilter","","Represents the different forms of texture filtering, which determines how a texture will be sampled when drawn.",null,null],[13,"Nearest","","When texturing a pixel, return the texel that is nearest to the center of the pixel.",77,null],[13,"Linear","","When texturing a pixel, return a weighted average of the four texels nearest to center of the pixel.",77,null],[4,"TextureMipmapFilter","","Represents the different forms of texture filtering when using mipmaps.",null,null],[13,"Filter","","Ignore mipmap values, and texture a pixel using a standard `TextureFilter`.",78,null],[13,"MipmapFilter","","Select the two mipmaps that are closest to the size of pixel being filled, and sample each one according to `criterion`. Finally, the result will be computed either by taking the weighted average of each texel, or by selecting the value from the closer texel, according to `mipmap`.",78,null],[12,"criterion","glitter::texture::TextureMipmapFilter","The method to use to select the texels from a mipmap.",78,null],[12,"mipmap","","The method to use to select the mipmaps.",78,null],[4,"TextureWrapMode","glitter::texture","The wrapping modes when drawing a texture.",null,null],[13,"ClampToEdge","","Wrap a texture by clamping it within the range `[1/2x, 1 - 1/2x]`, where `x` is the dimension of the texture being clamped.",79,null],[13,"MirroredRepeat","","Wrap a texture by repeating it front-to-back, then back-to-front, then repeating.",79,null],[13,"Repeat","","Wrap a texture by repeating it over and over again.",79,null],[6,"Texture2d","","An OpenGL texture with 2-dimensional image data.",null,null],[6,"TextureCubeMap","","An OpenGL texture used to hold a cubemap texture, made up of 6 2-dimensional images (one for each face of a cube).",null,null],[17,"TEXTURE_CUBE_MAP_POSITIVE_X","","The positive-X image target face of a cubemap.",null,null],[17,"TEXTURE_CUBE_MAP_NEGATIVE_X","","The negative-X image target face of a cubemap.",null,null],[17,"TEXTURE_CUBE_MAP_POSITIVE_Y","","The positive-Y image target face of a cubemap.",null,null],[17,"TEXTURE_CUBE_MAP_NEGATIVE_Y","","The negative-Y image target face of a cubemap.",null,null],[17,"TEXTURE_CUBE_MAP_POSITIVE_Z","","The positive-Z image target face of a cubemap.",null,null],[17,"TEXTURE_CUBE_MAP_NEGATIVE_Z","","The negative-Z image target face of a cubemap.",null,null],[17,"TEXTURE_CUBE_MAP","","This constant is designed to be used in glitter wherever the constant `GL_TEXTURE_CUBE_MAP` is used in plain OpenGL code.",null,null],[17,"TEXTURE_2D","","This constant is designed to be used in glitter wherever the constant `GL_TEXTURE_2D` is used in plain OpenGL code.",null,null],[17,"NEAREST","","When texturing a pixel, select the texel that is closest to the center of the pixel.",null,null],[17,"LINEAR","","When texturing a pixel, select the four texels that are closest to the center of the pixel, and compute the result by taking a weighted average of each texel.",null,null],[17,"NEAREST_MIPMAP_NEAREST","","When texturing a pixel, select the mipmap that is nearest in size to the pixel, and select the texel that is closest to the center of the pixel.",null,null],[17,"LINEAR_MIPMAP_NEAREST","","When texturing a pixel, select the mipmap that is nearest in size to the pixel, select the four texels that are closest to the center of the pixel, and compute the result by taking the weighted average of each texel.",null,null],[17,"NEAREST_MIPMAP_LINEAR","","When texturing a pixel, select the two mipmaps that are nearest in size to the pixel, select the texel in each that is closest to the center of the pixel, and compute the result by taking the weighted average of each texel.",null,null],[17,"LINEAR_MIPMAP_LINEAR","","When texturing a pixel, select the two mipmaps that are nearest in size to the pixel. For each, select the four texels that are closest to the center of the pixel, and compute the weighted average. Finally, take the resulting two weighted averages of the texels, and take the weighted average of both based on the mipmaps.",null,null],[17,"CLAMP_TO_EDGE","","Wrap a texture by clamping it within the range `[1/2x, 1 - 1/2x]`, where `x` is the dimension of the texture being clamped.",null,null],[17,"MIRRORED_REPEAT","","Wrap a texture by repeating it front-to-back, then back-to-front, then repeating.",null,null],[17,"REPEAT","","Wrap a texture by repeating it over and over again.",null,null],[8,"ImageTargetType","","A trait implemented for types that are used to represent all of the possible 2D images that make up a specific implementation of `TextureType`. For more details, read the `TextureType` documentation.",null,null],[10,"gl_enum","","Get the raw OpenGL enum value for an image target.",80,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[8,"TextureType","","A trait implemented for a type that represent a type of texture (such as 2D textures or cube map textures).  For example, [`TxCubeMap`] (struct.TxCubeMap.html) is a type that implements `TextureType`, and it represents cube map textures.",null,null],[16,"ImageTargetType","","The type that is used to indicate all of the possible target 2D images for this type of texture. The associated `ImageTargetType` in the impl for `TxCubeMap`, for example, is [`TxCubeMapImageTarget`] (enum.TxCubeMapImageTarget.html), which is an enum with six variants, one for each of the six 2-dimensional images that make up a cube map.",81,null],[10,"target","","The actual variant that represents this type of texture. The `target()` method impl for `TxCubeMap`, for example, returns `TextureBindingTarget::CubeMap`.",81,{"inputs":[],"output":{"name":"texturebindingtarget"}}],[11,"drop","","",82,{"inputs":[{"name":"self"}],"output":null}],[11,"from_raw","","",82,null],[11,"id","","",82,null],[11,"fmt","","",74,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",74,{"inputs":[{"name":"self"}],"output":{"name":"tx2dimagetarget"}}],[11,"eq","","",74,{"inputs":[{"name":"self"},{"name":"tx2dimagetarget"}],"output":{"name":"bool"}}],[11,"gl_enum","","",74,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[11,"target","","",83,{"inputs":[],"output":{"name":"texturebindingtarget"}}],[11,"fmt","","",75,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",75,{"inputs":[{"name":"self"}],"output":{"name":"txcubemapimagetarget"}}],[11,"eq","","",75,{"inputs":[{"name":"self"},{"name":"txcubemapimagetarget"}],"output":{"name":"bool"}}],[11,"hash","","",75,null],[11,"from_gl","","Convert from a raw OpenGL integer value to an enum variant. Returns an error if the value is not a valid enum variant.",75,{"inputs":[{"name":"glenum"}],"output":{"name":"result"}}],[11,"gl_enum","","Return the OpenGL integer value for a given enum variant.",75,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[11,"gl_enum","","",75,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[11,"target","","",84,{"inputs":[],"output":{"name":"texturebindingtarget"}}],[11,"fmt","","",76,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",76,{"inputs":[{"name":"self"}],"output":{"name":"texturebindingtarget"}}],[11,"eq","","",76,{"inputs":[{"name":"self"},{"name":"texturebindingtarget"}],"output":{"name":"bool"}}],[11,"gl_enum","","Convert a `TextureBindingTarget` into a raw OpenGL enum value.",76,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[11,"from","","",76,{"inputs":[{"name":"varianttexture2d"}],"output":{"name":"texturebindingtarget"}}],[11,"from","","",74,{"inputs":[{"name":"varianttexture2d"}],"output":{"name":"tx2dimagetarget"}}],[11,"gl_enum","","",85,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[11,"fmt","","",77,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",77,{"inputs":[{"name":"self"}],"output":{"name":"texturefilter"}}],[11,"eq","","",77,{"inputs":[{"name":"self"},{"name":"texturefilter"}],"output":{"name":"bool"}}],[11,"fmt","","",78,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",78,{"inputs":[{"name":"self"}],"output":{"name":"texturemipmapfilter"}}],[11,"eq","","",78,{"inputs":[{"name":"self"},{"name":"texturemipmapfilter"}],"output":{"name":"bool"}}],[11,"ne","","",78,{"inputs":[{"name":"self"},{"name":"texturemipmapfilter"}],"output":{"name":"bool"}}],[11,"gl_enum","","Convert a `TextureFilter` into a raw OpenGL enum value",77,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[11,"gl_enum","","Convert a `TextureMipmapFilter` into a raw OpenGL enum value",78,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[11,"from","","",78,{"inputs":[{"name":"texturefilter"}],"output":{"name":"texturemipmapfilter"}}],[11,"fmt","","",79,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",79,{"inputs":[{"name":"self"}],"output":{"name":"texturewrapmode"}}],[11,"eq","","",79,{"inputs":[{"name":"self"},{"name":"texturewrapmode"}],"output":{"name":"bool"}}],[11,"hash","","",79,null],[11,"from_gl","","Convert from a raw OpenGL integer value to an enum variant. Returns an error if the value is not a valid enum variant.",79,{"inputs":[{"name":"glenum"}],"output":{"name":"result"}}],[11,"gl_enum","","Return the OpenGL integer value for a given enum variant.",79,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[0,"image_data","glitter","Contains types related to 2D image data.",null,null],[3,"Pixel","glitter::image_data","A single OpenGL color value, with `u8` components laid out as a C struct in RGBA order. This type is the simplest implementation of `Image2d`, which allows it to be uploaded to a texture.",null,null],[12,"r","","The red component.",86,null],[12,"g","","The green component.",86,null],[12,"b","","The blue component.",86,null],[12,"a","","The alpha component.",86,null],[3,"Pixels","","A (heap-allocated) 2D image composed of a list of pixels.",null,null],[3,"ImageFormat","","A type that contains the texel type and format that make up a 2D image.",null,null],[12,"texel_type","","The texel type of the image.",87,null],[12,"texel_format","","The texel format of the image.",87,null],[4,"TexelType","","The data types for a texel.",null,null],[13,"UnsignedByte","","Each texel is 4 * 8 bits.",88,null],[13,"UnsignedShort565","","Each texel is 16 bits, with 5-bit/6-bit/5-bit components.",88,null],[13,"UnsignedShort4444","","Each texel is 16 bits, with 4, 4-bit components.",88,null],[13,"UnsignedShort5551","","Each texel is 16 bits, with 5-bit/5-bit/5-bit/1-bit components.",88,null],[4,"TexelFormat","","The different texel formats.",null,null],[13,"Alpha","","A texel contains only an alpha component.",89,null],[13,"RGB","","A texel contains red, green, and blue components.",89,null],[13,"RGBA","","A texel contains red, green, blue, and alpha components.",89,null],[4,"RenderbufferFormat","","The various image formats of a renderbuffer.",null,null],[13,"RGBA4","","The red, green, blue, and alpha channels are all stored with 4 bits.",90,null],[13,"RGB565","","The red, green, and blue channels are stored with 5 bits, 6 bits, and 5 bits, respectively.",90,null],[13,"RGB5A1","","The red, green, and blue channels are stored with 5 bits, and the alpha channel is stored with 1 bit.",90,null],[13,"DepthComponent16","","The renderbuffer stores a 16-bit depth component.",90,null],[13,"StencilIndex8","","The renderbuffer stores an 8-bit stencil component.",90,null],[17,"UNSIGNED_BYTE_TEXEL","","Each texel is 4 * 8 bits.",null,null],[17,"UNSIGNED_SHORT_5_6_5","","Each texel is 16 bits, with 5-bit/6-bit/5-bit components.",null,null],[17,"UNSIGNED_SHORT_4_4_4_4","","Each texel is 16 bits, with 4, 4-bit components.",null,null],[17,"UNSIGNED_SHORT_5_5_5_1","","Each texel is 16 bits, with 5-bit/5-bit/5-bit/1-bit components.",null,null],[17,"ALPHA","","A texel contains only an alpha component.",null,null],[17,"RGB","","A texel contains red, green, and blue components.",null,null],[17,"RGBA","","A texel contains red, green, blue, and alpha components.",null,null],[17,"RGBA4","","The red, green, blue, and alpha channels are all stored with 4 bits.",null,null],[17,"RGB565","","The red, green, and blue channels are stored with 5 bits, 6 bits, and 5 bits, respectively.",null,null],[17,"RGB5_A1","","The red, green, and blue channels are stored with 5 bits, and the alpha channel is stored with 1 bit.",null,null],[17,"DEPTH_COMPONENT16","","The renderbuffer stores a 16-bit depth component.",null,null],[17,"STENCIL_INDEX8","","The renderbuffer stores an 8-bit stencil component.",null,null],[8,"Image2d","","A trait for types that that contain 2D image data, which can be uploaded to a texture using a [`Texture2dBuilder`] (../context/texture_context/struct.Texture2dBuilder) or using the [`gl.image_2d`] (../context/texture_context/trait.ContextTextureExt.html#method.image_2d) method.",null,null],[10,"width","","Get the width of the image, in texels.",91,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"height","","Get the height of the image, in texels.",91,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"format","","Get the format of the image data that is returned by the `texel_bytes` method.",91,{"inputs":[{"name":"self"}],"output":{"name":"imageformat"}}],[10,"texel_bytes","","Get the raw texel data of the image data, as a `u8` slice.",91,null],[11,"fmt","","",86,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",86,{"inputs":[{"name":"self"}],"output":{"name":"pixel"}}],[11,"default","","",86,{"inputs":[],"output":{"name":"pixel"}}],[11,"r_g_b_a","","Create an RGBA color, provided each color component.",86,{"inputs":[{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"}],"output":{"name":"self"}}],[11,"r_g_b","","Create an RGBA color, provided the RGB components and using `0xFF` as the A value.",86,{"inputs":[{"name":"u8"},{"name":"u8"},{"name":"u8"}],"output":{"name":"self"}}],[11,"rgb","","Create an RGBA color, provided the RGB components as a packed `u32` value. The `u32` value will be read as `0x00RRGGBB`.",86,{"inputs":[{"name":"u32"}],"output":{"name":"self"}}],[11,"argb","","Create an RGBA color value, provided the components as a packed `u32` value. The `u32` value will be read as `0xAARRGGBB`.",86,{"inputs":[{"name":"u32"}],"output":{"name":"self"}}],[11,"rgba","","Create an RGBA color, provided the RGB components as a packed `u32` value. The `u32` value will be read as `0xRRGGBBAA`.",86,{"inputs":[{"name":"u32"}],"output":{"name":"self"}}],[11,"rgb_a","","Create an RGBA color, provided the RGB components as a packed `u32` value, and a separate A component. The `u32` value will be read as `0x00RRGGBB`.",86,{"inputs":[{"name":"u32"},{"name":"u8"}],"output":{"name":"self"}}],[11,"clone","","",92,{"inputs":[{"name":"self"}],"output":{"name":"pixels"}}],[11,"new","","Create a new image with the desired width and height. Pixels are initialized with [`Pixel::default()`] (https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default).",92,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"index","","",92,null],[11,"index_mut","","",92,null],[11,"width","","",92,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"height","","",92,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"format","","",92,{"inputs":[{"name":"self"}],"output":{"name":"imageformat"}}],[11,"texel_bytes","","",92,null],[11,"fmt","","",88,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",88,{"inputs":[{"name":"self"}],"output":{"name":"texeltype"}}],[11,"eq","","",88,{"inputs":[{"name":"self"},{"name":"texeltype"}],"output":{"name":"bool"}}],[11,"hash","","",88,null],[11,"from_gl","","Convert from a raw OpenGL integer value to an enum variant. Returns an error if the value is not a valid enum variant.",88,{"inputs":[{"name":"glenum"}],"output":{"name":"result"}}],[11,"gl_enum","","Return the OpenGL integer value for a given enum variant.",88,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[11,"fmt","","",89,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",89,{"inputs":[{"name":"self"}],"output":{"name":"texelformat"}}],[11,"eq","","",89,{"inputs":[{"name":"self"},{"name":"texelformat"}],"output":{"name":"bool"}}],[11,"hash","","",89,null],[11,"from_gl","","Convert from a raw OpenGL integer value to an enum variant. Returns an error if the value is not a valid enum variant.",89,{"inputs":[{"name":"glenum"}],"output":{"name":"result"}}],[11,"gl_enum","","Return the OpenGL integer value for a given enum variant.",89,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[11,"fmt","","",90,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",90,{"inputs":[{"name":"self"}],"output":{"name":"renderbufferformat"}}],[11,"eq","","",90,{"inputs":[{"name":"self"},{"name":"renderbufferformat"}],"output":{"name":"bool"}}],[11,"hash","","",90,null],[11,"from_gl","","Convert from a raw OpenGL integer value to an enum variant. Returns an error if the value is not a valid enum variant.",90,{"inputs":[{"name":"glenum"}],"output":{"name":"result"}}],[11,"gl_enum","","Return the OpenGL integer value for a given enum variant.",90,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[11,"fmt","","",87,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",87,{"inputs":[{"name":"self"}],"output":{"name":"imageformat"}}],[11,"rgba8","","Returns the RGBA image format with 8 bits per component.",87,{"inputs":[],"output":{"name":"self"}}],[0,"vertex_data","glitter","Contains types related to vertex data, which are used for [`VertexBuffers`] (../vertex_buffer/struct.VertexBuffer.html).",null,null],[3,"VertexAttribute","glitter::vertex_data","Specifies the type, name, and memory layout of a vertex attribute. Generally, a \"vertex attribute\" corresponds to a field in a [`VertexData`] (trait.VertexData.html) struct.",null,null],[12,"ty","","The type of the vertex attribute. This also specifies the number of bytes that make up a vertex attribute.",93,null],[12,"name","","The name of the vertex attribute. This value is used as the `$field_name` when binding vertex attribute pointers with the `attrib_pointers!` macro.",93,null],[12,"offset","","The number of bytes to \"move\" from the start of the vertex data to reach this vertex attribute.",93,null],[12,"stride","","The number of bytes between consecutive vertex attributes. 0 indicates that the vertex data is tightly packed.",93,null],[3,"VertexAttributeType","","Used to specify type of a vertex attribute. The size of the vertex attribute is `size_of(data) * components`.",null,null],[12,"data","","The type of data that makes up this vertex attribute.",94,null],[12,"components","","The number of `data` components that make up this vertex attribute.",94,null],[12,"normalize","","If the `data` type is fixed-point data, indicates if the data should be normalized when being accessed. `true` indicates that the vertex attribute should be normalized when being accessed.",94,null],[8,"VertexData","","A type that has vertex data.",null,null],[10,"visit_attributes","","Call the given function with each attribute that this vertex data is composed of.",95,{"inputs":[{"name":"f"}],"output":null}],[8,"VertexDatum","","A single value that can be treated as a part of a vertex. Implementors should map to a GLSL primitive that can be used as a vertex attribute. For example, `[f32; 2]` corresponds to `vec2` in memory layout and structure.",null,null],[10,"attrib_type","","Return the data type this datum corresponds to.",96,{"inputs":[],"output":{"name":"vertexattributetype"}}],[8,"VertexPrimitive","","A single, basic value that can be composed to make a [`VertexDatum`] (trait.VertexDatum.html). Scalar values are an example of a `VertexPrimitive`.",null,null],[10,"data_type","","Return the data type this primitive corresponds to.",97,{"inputs":[],"output":{"name":"datatype"}}],[8,"VertexBytes","","Indicates that a type can be coerced to a `u8` slice that can then be treated as a stream of vertex data.",null,null],[10,"vertex_bytes","","Create a byte slice of vertex data from `self`.",98,null],[11,"clone","","",93,{"inputs":[{"name":"self"}],"output":{"name":"vertexattribute"}}],[11,"clone","","",94,{"inputs":[{"name":"self"}],"output":{"name":"vertexattributetype"}}],[0,"vertex_buffer","glitter","Contains a higher-level abstraction for creating vertex and index buffer.",null,null],[3,"AttribError","glitter::vertex_buffer","An error generated when trying to iterate over the lists of attributes in an `AttribBinder`.",null,null],[3,"AttribBinder","","A type used to perform operations on a list of program attributes. An instance of an `AttribBinder` can be created with the [`attrib_pointers!`] (../macro.attrib_pointers!.html) macro or with the [`new`] (struct.AttribBinder.html#method.new) method.",null,null],[3,"VertexBuffer","","A buffer that contains vertex data. In addition to storing a buffer, a `VertexBuffer` stores an `AttribBinder` and a count of the amount of `VertexData` that has been buffered.",null,null],[3,"VertexBufferBinding","","Represents a `VertexBuffer` that has been bound to a context.",null,null],[3,"IndexBuffer","","A buffer that contains index data. In addition to storing a buffer, an `IndexBuffer` store a count of the amount of `IndexData` that has been buffered.",null,null],[3,"IndexBufferBinding","","Represents an `IndexBuffer` that has been bound to a context.",null,null],[4,"AttribAddError","","An error generated when trying add an attribute to an [`AttribBinder`] (struct.AttribBinder.html) using the [`AttribBinder::add`] (struct.AttribBinder.html#method.add) method.",null,null],[13,"DuplicateAttrib","","An attribute was added that already exists in the [`AttribBinder`] (struct.AttribBinder.html).",99,null],[4,"VertexBindError","","An error generated when binding vertex attributes.",null,null],[13,"BindingError","","An `AttribError` that was generated",100,null],[13,"NoAttributeBindings","","No attribute bindings were provided.",100,null],[8,"ContextVertexBufferExt","","An extension trait that adds vertex buffer and index buffer-related methods to OpenGL contexts.",null,null],[11,"new_vertex_buffer","","Create a new, empty vertex buffer.",101,{"inputs":[{"name":"self"}],"output":{"name":"vertexbuffer"}}],[11,"buffer_vertices","","Send data to a vertex buffer. Note that this will replace the buffer's current contents, if any.",101,null],[11,"buffer_indices","","Send data to an index buffer. Note that this will replace the buffer's current contents, if any.",101,null],[11,"draw_arrays_range_vbo","","Use the data from the provided vertex buffer binding to render primitives.",101,{"inputs":[{"name":"self"},{"name":"vertexbufferbinding"},{"name":"drawingmode"},{"name":"u32"},{"name":"usize"}],"output":null}],[11,"draw_arrays_vbo","","Use the data from the provided vertex buffer binding to render primitives. This function will use the full range of vertices that have been buffered.",101,{"inputs":[{"name":"self"},{"name":"vertexbufferbinding"},{"name":"drawingmode"}],"output":null}],[11,"draw_n_elements_buffered_vbo","","Draw primitives using the provided index buffer as the indices into the provided vertex buffer.",101,{"inputs":[{"name":"self"},{"name":"vertexbufferbinding"},{"name":"indexbufferbinding"},{"name":"drawingmode"},{"name":"usize"}],"output":null}],[11,"draw_elements_buffered_vbo","","Draw primitives using the provided index buffer as the indices into the provided vertex buffer. All buffered indices will be used.",101,{"inputs":[{"name":"self"},{"name":"vertexbufferbinding"},{"name":"indexbufferbinding"},{"name":"drawingmode"}],"output":null}],[11,"draw_n_elements_vbo","","Draw primitives specified by the provided index array, treated as indices into the provided vertex buffer.",101,null],[11,"draw_elements_vbo","","Draw primitives specified by the provided index array, treated as indices into the provided vertex buffer.",101,null],[8,"VertexBufferContext","","An OpenGL context that can have a vertex buffer bound.",null,null],[11,"bind_vertex_buffer","","Bind a vertex buffer to this context, returning a binding and a new context.",102,null],[8,"IndexBufferContext","","An OpenGL context that can have an index buffer bound.",null,null],[11,"bind_index_buffer","","Bind an index buffer to this context, returning a binding and the remaining context.",103,null],[11,"fmt","","",99,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",104,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new, empty `AttribBinder`.",105,{"inputs":[],"output":{"name":"self"}}],[11,"add","","Add an attribute to the `AttribBinder`.",105,{"inputs":[{"name":"self"},{"name":"str"},{"name":"programattrib"}],"output":{"name":"result"}}],[11,"enable","","Enable all of the vertex attributes contained within the `AttribBinder`. The provided type of `VertexData` is used to to verify the list of attributes.",105,{"inputs":[{"name":"self"},{"name":"c"}],"output":{"name":"result"}}],[11,"bind","","Set up each vertex attribute with the appropriate attribute options (using [`glVertexAttribPointer`] (http://docs.gl/es2/glVertexAttribPointer)). The `VertexData` type parameter is used to get the attribute options for each attribute.",105,{"inputs":[{"name":"self"},{"name":"c"}],"output":{"name":"result"}}],[11,"fmt","","",100,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",100,{"inputs":[{"name":"attriberror"}],"output":{"name":"vertexbinderror"}}],[11,"bind_attrib_pointers","","Set the `AttribBinder` that will contain all of the vertex attributes used when rendering.",106,{"inputs":[{"name":"self"},{"name":"attribbinder"}],"output":null}],[11,"buffer","","Get a reference to underlying OpenGL buffer.",106,{"inputs":[{"name":"self"}],"output":{"name":"buffer"}}],[11,"buffer_mut","","Get a mutable reference to the underlying OpenGL buffer.",106,{"inputs":[{"name":"self"}],"output":{"name":"buffer"}}],[11,"buffer","","Get a reference to the underlying OpenGL buffer.",107,{"inputs":[{"name":"self"}],"output":{"name":"buffer"}}],[11,"buffer_mut","","Get a mutable reference to the underlying OpenGL buffer.",107,{"inputs":[{"name":"self"}],"output":{"name":"buffer"}}],[11,"new_index_buffer","glitter::context","Create a new, empty index buffer.",4,{"inputs":[{"name":"self"}],"output":{"name":"indexbuffer"}}],[0,"index_data","glitter","Contains types related to index data, which are used for [`IndexBuffers`] (../vertex_buffer/struct.IndexBuffer.html).",null,null],[0,"mem","glitter::index_data","Basic functions for dealing with memory.",null,null],[5,"forget","glitter::index_data::mem","Leaks a value: takes ownership and \"forgets\" about the value without running its destructor.",null,null],[5,"size_of","","Returns the size of a type in bytes.",null,{"inputs":[],"output":{"name":"usize"}}],[5,"size_of_val","","Returns the size of the pointed-to value in bytes.",null,{"inputs":[{"name":"t"}],"output":{"name":"usize"}}],[5,"min_align_of","","Returns the [ABI]-required minimum alignment of a type.",null,{"inputs":[],"output":{"name":"usize"}}],[5,"min_align_of_val","","Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.",null,{"inputs":[{"name":"t"}],"output":{"name":"usize"}}],[5,"align_of","","Returns the [ABI]-required minimum alignment of a type.",null,{"inputs":[],"output":{"name":"usize"}}],[5,"align_of_val","","Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.",null,{"inputs":[{"name":"t"}],"output":{"name":"usize"}}],[5,"needs_drop","","Returns whether dropping values of type `T` matters.",null,{"inputs":[],"output":{"name":"bool"}}],[5,"zeroed","","Creates a value whose bytes are all zero.",null,{"inputs":[],"output":{"name":"t"}}],[5,"uninitialized","","Bypasses Rust's normal memory-initialization checks by pretending to produce a value of type `T`, while doing nothing at all.",null,{"inputs":[],"output":{"name":"t"}}],[5,"swap","","Swaps the values at two mutable locations, without deinitializing either one.",null,null],[5,"replace","","Replaces the value at a mutable location with a new one, returning the old value, without deinitializing either one.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"drop","","Disposes of a value.",null,null],[5,"transmute_copy","","Interprets `src` as having type `&U`, and then reads `src` without moving the contained value.",null,{"inputs":[{"name":"t"}],"output":{"name":"u"}}],[3,"Discriminant","","Opaque type representing the discriminant of an enum.",null,null],[5,"discriminant","","Returns a value uniquely identifying the enum variant in `v`.",null,{"inputs":[{"name":"t"}],"output":{"name":"discriminant"}}],[19,"ManuallyDrop","","A wrapper to inhibit compiler from automatically calling `T`’s destructor.",null,null],[5,"unreachable","","Tells LLVM that this point in the code is not reachable, enabling further optimizations.",null,null],[5,"transmute","","Reinterprets the bits of a value of one type as another type.",null,{"inputs":[{"name":"t"}],"output":{"name":"u"}}],[0,"slice","glitter::index_data","A dynamically-sized view into a contiguous sequence, `[T]`.",null,null],[8,"SliceConcatExt","glitter::index_data::slice","An extension trait for concatenating slices",null,null],[16,"Output","","The resulting type after concatenation",108,null],[10,"concat","","Flattens a slice of `T` into a single value `Self::Output`.",108,null],[10,"join","","Flattens a slice of `T` into a single value `Self::Output`, placing a given separator between each.",108,null],[10,"connect","","",108,null],[3,"Windows","","An iterator over overlapping subslices of length `size`.",null,null],[3,"RSplitN","","An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits, starting from the end of the slice.",null,null],[3,"RSplit","","An iterator over subslices separated by elements that match a predicate function, starting from the end of the slice.",null,null],[3,"Split","","An iterator over subslices separated by elements that match a predicate function.",null,null],[5,"from_ref_mut","","Converts a reference to T into a slice of length 1 (without copying).",null,null],[3,"Chunks","","An iterator over a slice in (non-overlapping) chunks (`size` elements at a time).",null,null],[5,"from_ref","","Converts a reference to T into a slice of length 1 (without copying).",null,null],[3,"SplitN","","An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits.",null,null],[5,"from_raw_parts_mut","","Performs the same functionality as `from_raw_parts`, except that a mutable slice is returned.",null,null],[3,"IterMut","","Mutable slice iterator.",null,null],[3,"ChunksMut","","An iterator over a slice in (non-overlapping) mutable chunks (`size` elements at a time). When the slice len is not evenly divided by the chunk size, the last slice of the iteration will be the remainder.",null,null],[3,"Iter","","Immutable slice iterator",null,null],[3,"RSplitNMut","","An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits, starting from the end of the slice.",null,null],[8,"SliceIndex","","A helper trait used for indexing operations.",null,null],[16,"Output","","The output type returned by methods.",109,null],[10,"get","","Returns a shared reference to the output at this location, if in bounds.",109,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"option"}}],[10,"get_mut","","Returns a mutable reference to the output at this location, if in bounds.",109,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"option"}}],[10,"get_unchecked","","Returns a shared reference to the output at this location, without performing any bounds checking.",109,null],[10,"get_unchecked_mut","","Returns a mutable reference to the output at this location, without performing any bounds checking.",109,null],[10,"index","","Returns a shared reference to the output at this location, panicking if out of bounds.",109,null],[10,"index_mut","","Returns a mutable reference to the output at this location, panicking if out of bounds.",109,null],[3,"SplitMut","","An iterator over the subslices of the vector which are separated by elements that match `pred`.",null,null],[5,"from_raw_parts","","Forms a slice from a pointer and a length.",null,null],[3,"SplitNMut","","An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits.",null,null],[3,"RSplitMut","","An iterator over the subslices of the vector which are separated by elements that match `pred`, starting from the end of the slice.",null,null],[4,"IndexDatumType","glitter::index_data","The set of possible `IndexDatum` types.",null,null],[13,"UnsignedByte","","Unsigned 8-bit index data.",110,null],[13,"UnsignedShort","","Unsigned 16-bit index data.",110,null],[8,"IndexData","","Indicates that a type can be coerced to a `u8` slice that can be treated as a stream of index data.",null,null],[10,"index_datum_type","","Return the data type that this index data should be treated as.",111,{"inputs":[],"output":{"name":"indexdatumtype"}}],[10,"index_bytes","","Create a byte slice of index data from `self`.",111,null],[10,"index_elements","","Return the number of index elements that `self` contains.",111,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[8,"IndexDatum","","A single value that can be treated as a single index.",null,null],[10,"index_datum_type","","Return the data type this datum corresponds to.",112,{"inputs":[],"output":{"name":"indexdatumtype"}}],[0,"uniform_data","glitter","Contains types that represent uniform data, which is used for methods such as [`gl.set_uniform`] (../context/program_context/trait.ContextProgramExt.html#method.set_uniform).",null,null],[4,"UniformPrimitiveType","glitter::uniform_data","The basic value types that are composed in the [`UniformDatumTypes`] (enum.UniformDatumType.html).",null,null],[13,"Float","","A 32-bit floating point value.",113,null],[13,"Int","","A 32-bit signed integer value.",113,null],[4,"UniformDatumType","","The basic types that can be used as uniform values in a program object.",null,null],[13,"Vec1","","A single scalar value, containing one primitive (essentially a vector of one component).",114,null],[13,"Vec2","","A vector with 2 components.",114,null],[13,"Vec3","","A vector with 3 components.",114,null],[13,"Vec4","","A vector with 4 components.",114,null],[13,"Matrix2x2","","A 2x2 matrix of floating-point values.",114,null],[13,"Matrix3x3","","A 3x3 matrix of floating-point values.",114,null],[13,"Matrix4x4","","A 4x4 matrix of floating-point values.",114,null],[8,"UniformData","","A type that can be set to a uniform value in a program object, using the [`gl.set_uniform`] (../context/program_context/trait.ContextProgramExt.html#method.set_uniform) method. A `UniformData` type can be composed of one or more `UniformDatums`, and this is likely the type that user types will implement.",null,null],[10,"uniform_datum_type","","Return the type that this uniform data should be treated as.",115,{"inputs":[],"output":{"name":"uniformdatumtype"}}],[10,"uniform_bytes","","Create a byte slice of uniform data from `self`.",115,null],[10,"uniform_elements","","Return the number of uniform data elements that `self` contains.",115,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[8,"UniformDatum","","A single uniform value, which corresponds to a single primitive GLSL uniform type.",null,null],[10,"uniform_datum_type","","Return the data type this datum corresponds to.",116,{"inputs":[],"output":{"name":"uniformdatumtype"}}],[8,"UniformPrimitive","","A single, basic value that can be composed to make a [`UniformDatum`] (trait.UniformDatum.html). Scalar values are an example of a `UniformPrimitive`.",null,null],[10,"uniform_primitive_type","","Return the data type this primitive corresponds to.",117,{"inputs":[],"output":{"name":"uniformprimitivetype"}}],[0,"types","glitter","Contains miscellaneous general-purpose OpenGL types.",null,null],[3,"Color","glitter::types","A color, with floating-point RGBA components.",null,null],[12,"r","","The color's red component.",118,null],[12,"g","","The color's green component.",118,null],[12,"b","","The color's blue component.",118,null],[12,"a","","The color's alpha component.",118,null],[3,"Viewport","","An OpenGL viewport, with an origin and size, with integer components.",null,null],[12,"x","","The X coordinate of the viewport's origin",119,null],[12,"y","","The Y coordinate of the viewport's origin",119,null],[12,"width","","The viewport's width",119,null],[12,"height","","The viewport's height",119,null],[3,"BufferBits","","The possible buffers that the active framebuffer may contain.",null,null],[4,"Capability","","The OpenGL drawing capabilities that can be enabled or disabled.",null,null],[13,"Blend","","Blend newly-computed fragment colors with the current values in the color buffer.",120,null],[13,"CullFace","","Cull polygons, based on their winding in window coordinates.",120,null],[13,"DepthTest","","Perform a depth test for each fragment, only drawing fragments that are not obscured by other geometry. Also updates the depth buffer appropriately.",120,null],[13,"Dither","","Dither color components or indices.",120,null],[13,"PolygonOffsetFill","","When filling a polygon, add an offset to each fragment's depth value.",120,null],[13,"SampleAlphaToCoverage","","When multisampling, use the alpha value from the sample location.",120,null],[13,"SampleCoverage","","When multisampling, use the preset sample coverage value as the alpha value.",120,null],[13,"ScisscorTest","","Only draw fragments within the scissor rectangle.",120,null],[13,"StencilTest","","Perform a stencil test for each fragment, only drawing fragments that pass the currently-set stencil operation. Also updates the stencil buffer appropriately.",120,null],[4,"GLError","","The various possible OpenGL errors.",null,null],[13,"InvalidEnum","","Indicates that an unexpected enum value was passed to a function.",121,null],[13,"InvalidValue","","Indicates that a function was passed an argument with a value that had an unexpected value (such as passing a negative value to a function that only expects positive arguments).",121,null],[13,"InvalidOperation","","Indicates that a particular operation was attempted that is not allowed, often resulting from an unexpected pairing of arguments.",121,null],[13,"InvalidFramebufferOperation","","Indicates that a particular operation attempted to use a framebuffer that is not framebuffer-complete.",121,null],[13,"OutOfMemory","","Indicates that the OpenGL driver could not allocate enough memory to satisfy a request.",121,null],[13,"FramebufferError","","Indicates a framebuffer-related error.",121,null],[13,"Message","","Indicates an error with a message attached (such as a message from an info log, or an error message originating from glitter).",121,null],[4,"GLFramebufferError","","The possible framebuffer-incomplete errors.",null,null],[13,"IncompleteAttachment","","Not all framebuffer attachments are [attachment-complete] (https://www.opengl.org/wiki/Framebuffer_Object#Attachment_Completeness).",122,null],[13,"IncompleteDimensions","","Not all attachments have the same dimensions.",122,null],[13,"IncompleteMissingAttachment","","The framebuffer has no attachments.",122,null],[13,"Unsupported","","The combination of attachment formats is unsupported by the current OpenGL implementation.",122,null],[4,"DrawingMode","","The primitive drawing modes for drawing raw vertex data.",null,null],[13,"Points","","Draw each vertex as a single point.",123,null],[13,"LineStrip","","Draw a connected line segment, where each vertex is connected to the next. The first and last vertex are treated as the start and end points.",123,null],[13,"LineLoop","","Draw a self-connected line segment, where each vertex is connected to the next, and the last vertex connects to the first.",123,null],[13,"Lines","","Draw each pair of vertices as individual line segments.",123,null],[13,"TriangleStrip","","Draw the vertices as a strip of triangles. The first three vertices form the first triangle, then the next vertex plus the previous two vertices form the next triangle, and so on. For example, vertices v1, v2, and v3 form the first triangle, then vertices v2, v3, and v4 form the next, and so on.",123,null],[13,"TriangleFan","","Draw the vertices as a triangle fan. The first vertex, v1 is the fan's 'center'. Vertices v2 and v3 form the first triangle with the center, v1. Then vertices v3, v4, and v1 form the next triangle, then vertices v4, v5, and v1, and so on.",123,null],[13,"Triangles","","Draw each group of three vertices as a triangle.",123,null],[4,"DataType","","The different OpenGL data types.",null,null],[13,"Byte","","A signed 8-bit byte.",124,null],[13,"UnsignedByte","","An unsigned 8-bit byte.",124,null],[13,"Short","","A signed 16-bit short.",124,null],[13,"UnsignedShort","","An unsigned 16-bit short.",124,null],[13,"Fixed","","A signed 32-bit, fixed-point number in 16.16 form.",124,null],[13,"Float","","A 32-bit, IEEE floating-point number.",124,null],[17,"COLOR_BUFFER_BIT","","The color buffer, which stores color information for each fragment (or pixel).",null,null],[17,"DEPTH_BUFFER_BIT","","The depth buffer, which stores distance information for each fragment when depth testing is enabled.",null,null],[17,"STENCIL_BUFFER_BIT","","The stencil buffer, which stores information about which fragments should be kept or discarded when stencil testing is enabled.",null,null],[17,"BLEND","","Blend newly-computed fragment colors with the current values in the color buffer.",null,null],[17,"CULL_FACE","","Cull polygons, based on their winding in window coordinates.",null,null],[17,"DEPTH_TEST","","Perform a depth test for each fragment, only drawing fragments that are not obscured by other geometry. Also updates the depth buffer appropriately.",null,null],[17,"DITHER","","Dither color components or indices.",null,null],[17,"POLYGON_OFFSET_FILL","","When filling a polygon, add an offset to each fragment's depth value.",null,null],[17,"SAMPLE_ALPHA_TO_COVERAGE","","When multisampling, use the alpha value from the sample location.",null,null],[17,"SAMPLE_COVERAGE","","When multisampling, use the preset sample coverage value as the alpha value.",null,null],[17,"SCISSCOR_TEST","","Only draw fragments within the scissor rectangle.",null,null],[17,"STENCIL_TEST","","Perform a stencil test for each fragment, only drawing fragments that pass the currently-set stencil operation. Also updates the stencil buffer appropriately.",null,null],[17,"POINTS","","Draw each vertex as a single point.",null,null],[17,"LINE_STRIP","","Draw a connected line segment, where each vertex is connected to the next. The first and last vertex are treated as the start and end points.",null,null],[17,"LINE_LOOP","","Draw a self-connected line segment, where each vertex is connected to the next, and the last vertex connects to the first.",null,null],[17,"LINES","","Draw each pair of vertices as individual line segments.",null,null],[17,"TRIANGLE_STRIP","","Draw the vertices as a strip of triangles. The first three vertices form the first triangle, then the next vertex plus the previous two vertices form the next triangle, and so on. For example, vertices v1, v2, and v3 form the first triangle, then vertices v2, v3, and v4 form the next, and so on.",null,null],[17,"TRIANGLE_FAN","","Draw the vertices as a triangle fan. The first vertex, v1 is the fan's 'center'. Vertices v2 and v3 form the first triangle with the center, v1. Then vertices v3, v4, and v1 form the next triangle, then vertices v4, v5, and v1, and so on.",null,null],[17,"TRIANGLES","","Draw each group of three vertices as a triangle.",null,null],[17,"BYTE","","A signed 8-bit byte.",null,null],[17,"UNSIGNED_BYTE","","An unsigned 8-bit byte.",null,null],[17,"SHORT","","A signed 16-bit short.",null,null],[17,"UNSIGNED_SHORT","","An unsigned 16-bit short.",null,null],[17,"FIXED","","A signed 32-bit, fixed-point number in 16.16 form.",null,null],[17,"FLOAT","","A 32-bit, IEEE floating-point number.",null,null],[8,"GLObject","","An OpenGL object.",null,null],[16,"Id","","The type of the object's internal ID.",125,null],[10,"from_raw","","Get a new object from an OpenGL ID.",125,null],[10,"id","","Get the object's ID.",125,null],[11,"into_raw","","Consume the object without cleaning up its resources, returning the object's ID.",125,null],[11,"rgba","","Create a new color, with the specified RGBA values.",118,{"inputs":[{"name":"f32"},{"name":"f32"},{"name":"f32"},{"name":"f32"}],"output":{"name":"self"}}],[11,"clone","","",119,{"inputs":[{"name":"self"}],"output":{"name":"viewport"}}],[11,"new","","Create a new viewport, with the given X and Y coordinates as the origin and the given width and height as the size.",119,{"inputs":[{"name":"u32"},{"name":"u32"},{"name":"u32"},{"name":"u32"}],"output":{"name":"self"}}],[11,"eq","","",126,{"inputs":[{"name":"self"},{"name":"bufferbits"}],"output":{"name":"bool"}}],[11,"ne","","",126,{"inputs":[{"name":"self"},{"name":"bufferbits"}],"output":{"name":"bool"}}],[11,"clone","","",126,{"inputs":[{"name":"self"}],"output":{"name":"bufferbits"}}],[11,"partial_cmp","","",126,{"inputs":[{"name":"self"},{"name":"bufferbits"}],"output":{"name":"option"}}],[11,"lt","","",126,{"inputs":[{"name":"self"},{"name":"bufferbits"}],"output":{"name":"bool"}}],[11,"le","","",126,{"inputs":[{"name":"self"},{"name":"bufferbits"}],"output":{"name":"bool"}}],[11,"gt","","",126,{"inputs":[{"name":"self"},{"name":"bufferbits"}],"output":{"name":"bool"}}],[11,"ge","","",126,{"inputs":[{"name":"self"},{"name":"bufferbits"}],"output":{"name":"bool"}}],[11,"cmp","","",126,{"inputs":[{"name":"self"},{"name":"bufferbits"}],"output":{"name":"ordering"}}],[11,"hash","","",126,null],[11,"fmt","","",126,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",126,{"inputs":[],"output":{"name":"bufferbits"}}],[11,"all","","Returns the set containing all flags.",126,{"inputs":[],"output":{"name":"bufferbits"}}],[11,"bits","","Returns the raw value of the flags currently stored.",126,{"inputs":[{"name":"self"}],"output":{"name":"glbitfield"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",126,{"inputs":[{"name":"glbitfield"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",126,{"inputs":[{"name":"glbitfield"}],"output":{"name":"bufferbits"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",126,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",126,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",126,{"inputs":[{"name":"self"},{"name":"bufferbits"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",126,{"inputs":[{"name":"self"},{"name":"bufferbits"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",126,{"inputs":[{"name":"self"},{"name":"bufferbits"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",126,{"inputs":[{"name":"self"},{"name":"bufferbits"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",126,{"inputs":[{"name":"self"},{"name":"bufferbits"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",126,{"inputs":[{"name":"self"},{"name":"bufferbits"}],"output":{"name":"bufferbits"}}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",126,{"inputs":[{"name":"self"},{"name":"bufferbits"}],"output":{"name":"bufferbits"}}],[11,"bitand","","Returns the intersection between the two sets of flags.",126,{"inputs":[{"name":"self"},{"name":"bufferbits"}],"output":{"name":"bufferbits"}}],[11,"sub","","Returns the set difference of the two sets of flags.",126,{"inputs":[{"name":"self"},{"name":"bufferbits"}],"output":{"name":"bufferbits"}}],[11,"not","","Returns the complement of this set of flags.",126,{"inputs":[{"name":"self"}],"output":{"name":"bufferbits"}}],[11,"from_iter","","",126,{"inputs":[{"name":"t"}],"output":{"name":"bufferbits"}}],[11,"fmt","","",120,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",120,{"inputs":[{"name":"self"}],"output":{"name":"capability"}}],[11,"eq","","",120,{"inputs":[{"name":"self"},{"name":"capability"}],"output":{"name":"bool"}}],[11,"hash","","",120,null],[11,"from_gl","","Convert from a raw OpenGL integer value to an enum variant. Returns an error if the value is not a valid enum variant.",120,{"inputs":[{"name":"glenum"}],"output":{"name":"result"}}],[11,"gl_enum","","Return the OpenGL integer value for a given enum variant.",120,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[11,"fmt","","",121,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",121,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",121,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",121,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",122,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",122,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",122,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"from","","",121,{"inputs":[{"name":"glframebuffererror"}],"output":{"name":"glerror"}}],[11,"fmt","","",123,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",123,{"inputs":[{"name":"self"}],"output":{"name":"drawingmode"}}],[11,"eq","","",123,{"inputs":[{"name":"self"},{"name":"drawingmode"}],"output":{"name":"bool"}}],[11,"hash","","",123,null],[11,"from_gl","","Convert from a raw OpenGL integer value to an enum variant. Returns an error if the value is not a valid enum variant.",123,{"inputs":[{"name":"glenum"}],"output":{"name":"result"}}],[11,"gl_enum","","Return the OpenGL integer value for a given enum variant.",123,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[11,"fmt","","",124,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",124,{"inputs":[{"name":"self"}],"output":{"name":"datatype"}}],[11,"eq","","",124,{"inputs":[{"name":"self"},{"name":"datatype"}],"output":{"name":"bool"}}],[11,"hash","","",124,null],[11,"from_gl","","Convert from a raw OpenGL integer value to an enum variant. Returns an error if the value is not a valid enum variant.",124,{"inputs":[{"name":"glenum"}],"output":{"name":"result"}}],[11,"gl_enum","","Return the OpenGL integer value for a given enum variant.",124,{"inputs":[{"name":"self"}],"output":{"name":"glenum"}}],[11,"from","glitter::image_data","",86,{"inputs":[{"name":"p"}],"output":{"name":"pixel"}}],[11,"from","","",92,{"inputs":[{"name":"i"}],"output":{"name":"pixels"}}],[0,"prelude","glitter","Re-exports essential extension traits. Everything exported in this module should be used anywhere that glitter is used.",null,null],[14,"offset_of","","Compute the offset of a field within a struct type.",null,null],[14,"impl_vertex_data","","Implement the `VertexData` trait for a struct. Each field of the struct must that is part of the `VertexData` implementation must be a type that implements [`VertexDatum`] (vertex_data/trait.VertexDatum.html).",null,null],[14,"attrib_pointers","","Create an `AttribBinder` from a set of associations from vertex attribute names to [`ProgramAttribs`] (program/struct.ProgramAttrib.html).",null,null],[11,"clone","glitter::index_data::mem","",127,{"inputs":[{"name":"self"}],"output":{"name":"manuallydrop"}}],[11,"clone_from","","",127,null],[11,"clone","glitter::index_data::slice","",128,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"clone","","",129,{"inputs":[{"name":"self"}],"output":{"name":"split"}}],[11,"clone","","",130,{"inputs":[{"name":"self"}],"output":{"name":"windows"}}],[11,"clone","","",131,{"inputs":[{"name":"self"}],"output":{"name":"rsplit"}}],[11,"clone","","",132,{"inputs":[{"name":"self"}],"output":{"name":"chunks"}}],[11,"clone","glitter::index_data::mem","",133,{"inputs":[{"name":"self"}],"output":{"name":"discriminant"}}],[11,"partial_cmp","","",127,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"option"}}],[11,"lt","","",127,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"bool"}}],[11,"le","","",127,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"bool"}}],[11,"gt","","",127,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"bool"}}],[11,"ge","","",127,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"bool"}}],[11,"deref","","",127,null],[11,"as_ref","glitter::index_data::slice","",128,null],[11,"fmt","","",129,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",134,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",131,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",135,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","glitter::index_data::mem","",133,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","glitter::index_data::slice","",128,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",136,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",137,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",132,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","glitter::index_data::mem","",127,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","glitter::index_data::slice","",138,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",139,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",130,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",140,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",141,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"deref_mut","glitter::index_data::mem","",127,null],[11,"cmp","","",127,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"ordering"}}],[11,"eq","","",127,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"bool"}}],[11,"ne","","",127,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"bool"}}],[11,"eq","","",133,{"inputs":[{"name":"self"},{"name":"discriminant"}],"output":{"name":"bool"}}],[11,"next","glitter::index_data::slice","",137,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",137,null],[11,"count","","",137,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",137,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",137,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"all","","",137,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"bool"}}],[11,"any","","",137,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"bool"}}],[11,"find","","",137,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"position","","",137,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"rposition","","",137,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"next","","",135,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",135,null],[11,"next","","",140,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",140,null],[11,"next","","",141,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",141,null],[11,"next","","",128,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",128,null],[11,"count","","",128,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",128,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",128,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"all","","",128,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"bool"}}],[11,"any","","",128,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"bool"}}],[11,"find","","",128,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"position","","",128,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"rposition","","",128,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"next","","",129,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",129,null],[11,"next","","",132,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",132,null],[11,"count","","",132,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",132,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",132,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","","",139,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",139,null],[11,"next","","",138,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",138,null],[11,"next","","",130,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",130,null],[11,"count","","",130,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",130,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",130,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","","",136,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",136,null],[11,"next","","",134,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",134,null],[11,"count","","",134,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",134,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",134,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","","",131,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",131,null],[11,"is_empty","","",137,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_empty","","",128,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"next_back","","",131,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",130,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",132,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",139,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",129,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",137,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"rfind","","",137,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"next_back","","",134,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",128,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"rfind","","",128,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"next_back","","",135,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"hash","glitter::index_data::mem","",133,null],[11,"hash","","",127,null],[11,"default","","",127,{"inputs":[],"output":{"name":"manuallydrop"}}],[11,"new","","Wrap a value to be manually dropped.",127,{"inputs":[{"name":"t"}],"output":{"name":"manuallydrop"}}],[11,"into_inner","","Extract the value from the ManuallyDrop container.",127,{"inputs":[{"name":"manuallydrop"}],"output":{"name":"t"}}],[11,"drop","","Manually drops the contained value.",127,null],[11,"into_slice","glitter::index_data::slice","View the underlying data as a subslice of the original data.",137,null],[11,"as_slice","","View the underlying data as a subslice of the original data.",128,null]],"paths":[[8,"ContextBufferExt"],[8,"ArrayBufferContext"],[8,"ElementArrayBufferContext"],[8,"BufferBinding"],[3,"ContextOf"],[3,"ArrayBufferBinding"],[3,"ElementArrayBufferBinding"],[3,"BufferBinderOf"],[3,"ArrayBufferBinder"],[3,"ElementArrayBufferBinder"],[4,"FramebufferTarget"],[4,"FramebufferAttachment"],[8,"ContextFramebufferExt"],[8,"ContextFramebufferBuilderExt"],[8,"FramebufferContext"],[3,"FramebufferBuilder"],[3,"FramebufferBinder"],[8,"ContextProgramBuilderExt"],[8,"ContextProgramExt"],[8,"ProgramContext"],[3,"ProgramBuilder"],[3,"ProgramBinder"],[3,"UnknownProgramAttrib"],[3,"UnknownProgramUniform"],[8,"ContextRenderbufferBuilderExt"],[8,"ContextRenderbufferExt"],[8,"RenderbufferContext"],[3,"RenderbufferBuilder"],[3,"RenderbufferBinder"],[8,"ContextTextureBuilderExt"],[8,"ContextTextureExt"],[8,"TextureBinding"],[3,"Texture2dBuilder"],[3,"Texture2dBinding"],[3,"TextureCubeMapBinding"],[3,"Texture2dBinder"],[3,"TextureCubeMapBinder"],[3,"TextureUnitsOf"],[8,"TextureUnit"],[8,"TextureUnit0Context"],[8,"TextureUnit1Context"],[8,"TextureUnit2Context"],[8,"TextureUnit3Context"],[8,"TextureUnit4Context"],[8,"TextureUnit5Context"],[8,"TextureUnit6Context"],[8,"TextureUnit7Context"],[8,"TextureUnitBinding2d"],[8,"TextureUnitBindingCubeMap"],[3,"TextureUnit0"],[3,"TextureUnit1"],[3,"TextureUnit2"],[3,"TextureUnit3"],[3,"TextureUnit4"],[3,"TextureUnit5"],[3,"TextureUnit6"],[3,"TextureUnit7"],[3,"TextureUnitBindingOf"],[3,"TextureSampler"],[8,"ContextExt"],[4,"BufferDataUsage"],[4,"BufferBindingTarget"],[3,"Buffer"],[4,"ShaderType"],[8,"ContextShaderBuilderExt"],[8,"ContextShaderExt"],[3,"Shader"],[3,"ShaderBuilder"],[3,"ProgramAttrib"],[3,"ProgramUniform"],[3,"Program"],[3,"Framebuffer"],[4,"RenderbufferTarget"],[3,"Renderbuffer"],[4,"Tx2dImageTarget"],[4,"TxCubeMapImageTarget"],[4,"TextureBindingTarget"],[4,"TextureFilter"],[4,"TextureMipmapFilter"],[4,"TextureWrapMode"],[8,"ImageTargetType"],[8,"TextureType"],[3,"Texture"],[3,"Tx2d"],[3,"TxCubeMap"],[3,"VariantTexture2d"],[3,"Pixel"],[3,"ImageFormat"],[4,"TexelType"],[4,"TexelFormat"],[4,"RenderbufferFormat"],[8,"Image2d"],[3,"Pixels"],[3,"VertexAttribute"],[3,"VertexAttributeType"],[8,"VertexData"],[8,"VertexDatum"],[8,"VertexPrimitive"],[8,"VertexBytes"],[4,"AttribAddError"],[4,"VertexBindError"],[8,"ContextVertexBufferExt"],[8,"VertexBufferContext"],[8,"IndexBufferContext"],[3,"AttribError"],[3,"AttribBinder"],[3,"VertexBuffer"],[3,"IndexBuffer"],[8,"SliceConcatExt"],[8,"SliceIndex"],[4,"IndexDatumType"],[8,"IndexData"],[8,"IndexDatum"],[4,"UniformPrimitiveType"],[4,"UniformDatumType"],[8,"UniformData"],[8,"UniformDatum"],[8,"UniformPrimitive"],[3,"Color"],[3,"Viewport"],[4,"Capability"],[4,"GLError"],[4,"GLFramebufferError"],[4,"DrawingMode"],[4,"DataType"],[8,"GLObject"],[3,"BufferBits"],[19,"ManuallyDrop"],[3,"Iter"],[3,"Split"],[3,"Windows"],[3,"RSplit"],[3,"Chunks"],[3,"Discriminant"],[3,"ChunksMut"],[3,"RSplitMut"],[3,"RSplitN"],[3,"IterMut"],[3,"RSplitNMut"],[3,"SplitMut"],[3,"SplitNMut"],[3,"SplitN"]]};
initSearch(searchIndex);
